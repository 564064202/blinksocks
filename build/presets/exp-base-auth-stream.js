'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _crypto=require('crypto');var _crypto2=_interopRequireDefault(_crypto);var _ip=require('ip');var _ip2=_interopRequireDefault(_ip);var _utils=require('../utils');var _defs=require('./defs');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const ATYP_V4=1;const ATYP_V6=4;const IV_LEN=16;const HMAC_LEN=16;const ciphers=['aes-128-ctr','aes-192-ctr','aes-256-ctr','aes-128-cfb','aes-192-cfb','aes-256-cfb','camellia-128-cfb','camellia-192-cfb','camellia-256-cfb'];class ExpBaseAuthStreamPreset extends _defs.IPreset{constructor({method}){super();this._isHandshakeDone=false;this._host=null;this._port=null;this._cipherName='';this._cipher=null;this._decipher=null;if(typeof method!=='string'||method===''){throw Error('\'method\' must be set')}if(!ciphers.includes(method)){throw Error(`method '${method}' is not supported.`)}this._cipherName=method}onNotified(action){if(__IS_CLIENT__&&action.type===_defs.PROXY_HANDSHAKE_DONE){var _action$payload$targe=action.payload.targetAddress;const type=_action$payload$targe.type,host=_action$payload$targe.host,port=_action$payload$targe.port;if(type===ATYP_V4||type===ATYP_V6){this._host=Buffer.from(_ip2.default.toString(host))}else{this._host=Buffer.from(host)}this._port=(0,_utils.numberToBuffer)(port)}}clientOut({buffer}){if(!this._isHandshakeDone){this._isHandshakeDone=true;const iv=_crypto2.default.randomBytes(IV_LEN);const keyForEncryption=(0,_utils.EVP_BytesToKey)(__KEY__,this._cipherName.split('-')[1]/8,IV_LEN);const keyForHMAC=(0,_utils.Xor)(iv,keyForEncryption.slice(0,IV_LEN));this._cipher=_crypto2.default.createCipheriv(this._cipherName,keyForEncryption,iv);this._decipher=_crypto2.default.createDecipheriv(this._cipherName,keyForEncryption,iv);const encBuf=this.encrypt(Buffer.concat([(0,_utils.numberToBuffer)(this._host.length,1),this._host,this._port,buffer]));const hmacEncAddr=(0,_utils.hmac)('sha1',keyForHMAC,encBuf.slice(0,-buffer.length)).slice(0,HMAC_LEN);return Buffer.concat([iv,hmacEncAddr,encBuf])}else{return this.encrypt(buffer)}}serverIn({buffer,next,broadcast,fail}){if(!this._isHandshakeDone){if(buffer.length<37){return fail(`unexpected buffer length_1: ${buffer.length}, buffer=${buffer.toString('hex')}`)}const iv=buffer.slice(0,IV_LEN);const keyForEncryption=(0,_utils.EVP_BytesToKey)(__KEY__,this._cipherName.split('-')[1]/8,IV_LEN);this._cipher=_crypto2.default.createCipheriv(this._cipherName,keyForEncryption,iv);this._decipher=_crypto2.default.createDecipheriv(this._cipherName,keyForEncryption,iv);const tailBuffer=this.decrypt(buffer.slice(32));const providedHmac=buffer.slice(16,32);const alen=tailBuffer[0];if(buffer.length<=35+alen){return fail(`unexpected buffer length_2: ${buffer.length}, buffer=${buffer.toString('hex')}`)}const keyForHMAC=(0,_utils.Xor)(iv,keyForEncryption.slice(0,IV_LEN));const expHmac=(0,_utils.hmac)('sha1',keyForHMAC,buffer.slice(32,35+alen)).slice(0,HMAC_LEN);if(!expHmac.equals(providedHmac)){return fail(`unexpected HMAC-SHA1=${providedHmac.toString('hex')} want=${expHmac.toString('hex')}`)}const addr=tailBuffer.slice(1,alen+1).toString();const port=tailBuffer.slice(alen+1,alen+3).readUInt16BE(0);const data=tailBuffer.slice(alen+3);broadcast({type:_defs.SOCKET_CONNECT_TO_DST,payload:{targetAddress:{host:addr,port},onConnected:()=>{next(data);this._isHandshakeDone=true}}})}else{return this.decrypt(buffer)}}serverOut({buffer}){return this.encrypt(buffer)}clientIn({buffer}){return this.decrypt(buffer)}encrypt(buffer){return this._cipher.update(buffer)}decrypt(buffer){return this._decipher.update(buffer)}}exports.default=ExpBaseAuthStreamPreset;