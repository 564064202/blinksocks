'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _crypto=require('crypto');var _crypto2=_interopRequireDefault(_crypto);var _utils=require('../utils');var _defs=require('./defs');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const IV_LEN=16;const HMAC_LEN=16;const ciphers=['aes-128-ctr','aes-192-ctr','aes-256-ctr','aes-128-cfb','aes-192-cfb','aes-256-cfb','camellia-128-cfb','camellia-192-cfb','camellia-256-cfb'];class ExpBaseAuthStreamPreset extends _defs.IPreset{constructor({method}){super();this._isHandshakeDone=false;this._isBroadCasting=false;this._staging=Buffer.alloc(0);this._host=null;this._port=null;this._cipherName='';this._cipher=null;this._decipher=null;if(typeof method!=='string'||method===''){throw Error('\'method\' must be set')}if(!ciphers.includes(method)){throw Error(`method '${method}' is not supported.`)}this._cipherName=method}onNotified(action){if(__IS_CLIENT__&&action.type===_defs.SOCKET_CONNECT_TO_REMOTE){var _action$payload=action.payload;const host=_action$payload.host,port=_action$payload.port;this._host=Buffer.from(host);this._port=(0,_utils.numberToBuffer)(port)}}clientOut({buffer}){if(!this._isHandshakeDone){this._isHandshakeDone=true;const iv=_crypto2.default.randomBytes(IV_LEN);const keyForEncryption=(0,_utils.EVP_BytesToKey)(__KEY__,this._cipherName.split('-')[1]/8,IV_LEN);const keyForHMAC=(0,_utils.Xor)(iv,keyForEncryption.slice(0,IV_LEN));this._cipher=_crypto2.default.createCipheriv(this._cipherName,keyForEncryption,iv);this._decipher=_crypto2.default.createDecipheriv(this._cipherName,keyForEncryption,iv);const encBuf=this.encrypt(Buffer.concat([(0,_utils.numberToBuffer)(this._host.length,1),this._host,this._port,buffer]));const hmacEncAddr=(0,_utils.hmac)('sha1',keyForHMAC,encBuf.slice(0,-buffer.length)).slice(0,HMAC_LEN);return Buffer.concat([iv,hmacEncAddr,encBuf])}else{return this.encrypt(buffer)}}serverIn({buffer,next,broadcast,fail}){if(!this._isHandshakeDone){if(this._isBroadCasting){this._staging=Buffer.concat([this._staging,buffer]);return}if(buffer.length<37){return fail(`unexpected buffer length_1: ${buffer.length}, buffer=${buffer.toString('hex')}`)}const iv=buffer.slice(0,IV_LEN);const keyForEncryption=(0,_utils.EVP_BytesToKey)(__KEY__,this._cipherName.split('-')[1]/8,IV_LEN);this._cipher=_crypto2.default.createCipheriv(this._cipherName,keyForEncryption,iv);this._decipher=_crypto2.default.createDecipheriv(this._cipherName,keyForEncryption,iv);const tailBuffer=this.decrypt(buffer.slice(32));const providedHmac=buffer.slice(16,32);const alen=tailBuffer[0];if(buffer.length<=35+alen){return fail(`unexpected buffer length_2: ${buffer.length}, buffer=${buffer.toString('hex')}`)}const keyForHMAC=(0,_utils.Xor)(iv,keyForEncryption.slice(0,IV_LEN));const expHmac=(0,_utils.hmac)('sha1',keyForHMAC,buffer.slice(32,35+alen)).slice(0,HMAC_LEN);if(!expHmac.equals(providedHmac)){return fail(`unexpected HMAC-SHA1=${providedHmac.toString('hex')} want=${expHmac.toString('hex')}`)}const addr=tailBuffer.slice(1,alen+1).toString();const port=tailBuffer.slice(alen+1,alen+3).readUInt16BE(0);const data=tailBuffer.slice(alen+3);this._isBroadCasting=true;broadcast({type:_defs.SOCKET_CONNECT_TO_REMOTE,payload:{host:addr,port:port,onConnected:()=>{next(Buffer.concat([data,this._staging]));this._isHandshakeDone=true;this._isBroadCasting=false;this._staging=null}}})}else{return this.decrypt(buffer)}}serverOut({buffer}){return this.encrypt(buffer)}clientIn({buffer}){return this.decrypt(buffer)}encrypt(buffer){return this._cipher.update(buffer)}decrypt(buffer){return this._decipher.update(buffer)}}exports.default=ExpBaseAuthStreamPreset;