'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();var _crypto=require('crypto');var _crypto2=_interopRequireDefault(_crypto);var _defs=require('./defs');var _utils=require('../utils');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const ciphers={'aes-128-ctr':[16,16],'aes-192-ctr':[24,16],'aes-256-ctr':[32,16],'aes-128-cfb':[16,16],'aes-192-cfb':[24,16],'aes-256-cfb':[32,16],'camellia-128-cfb':[16,16],'camellia-192-cfb':[24,16],'camellia-256-cfb':[32,16]};class SsStreamCipherPreset extends _defs.IPreset{constructor(...args){var _temp;return _temp=super(...args),this._cipher=null,this._decipher=null,_temp}static checkParams({method}){if(typeof method!=='string'||method===''){throw Error('\'method\' must be set')}const cipherNames=Object.keys(ciphers);if(!cipherNames.includes(method)){throw Error(`'method' must be one of [${cipherNames}]`)}}static onInit({method}){var _ciphers$method=_slicedToArray(ciphers[method],2);const keySize=_ciphers$method[0],ivSize=_ciphers$method[1];SsStreamCipherPreset.cipherName=method;SsStreamCipherPreset.key=(0,_utils.EVP_BytesToKey)(__KEY__,keySize,ivSize);SsStreamCipherPreset.ivSize=ivSize}onDestroy(){this._cipher=null;this._decipher=null}beforeOut({buffer}){if(!this._cipher){const cipherName=SsStreamCipherPreset.cipherName,key=SsStreamCipherPreset.key,ivSize=SsStreamCipherPreset.ivSize;const iv=_crypto2.default.randomBytes(ivSize);this._cipher=_crypto2.default.createCipheriv(cipherName,key,iv);return Buffer.concat([iv,this._cipher.update(buffer)])}else{return this._cipher.update(buffer)}}beforeIn({buffer,fail}){if(!this._decipher){const cipherName=SsStreamCipherPreset.cipherName,key=SsStreamCipherPreset.key,ivSize=SsStreamCipherPreset.ivSize;if(buffer.length<ivSize){return fail(`buffer is too short to get iv, len=${buffer.length} dump=${buffer.toString('hex')}`)}const iv=buffer.slice(0,ivSize);this._decipher=_crypto2.default.createDecipheriv(cipherName,key,iv);return this._decipher.update(buffer.slice(ivSize))}else{return this._decipher.update(buffer)}}beforeOutUdp({buffer}){const cipherName=SsStreamCipherPreset.cipherName,key=SsStreamCipherPreset.key,ivSize=SsStreamCipherPreset.ivSize;const iv=_crypto2.default.randomBytes(ivSize);const cipher=_crypto2.default.createCipheriv(cipherName,key,iv);return Buffer.concat([iv,cipher.update(buffer),cipher.final()])}beforeInUdp({buffer,fail}){const cipherName=SsStreamCipherPreset.cipherName,key=SsStreamCipherPreset.key,ivSize=SsStreamCipherPreset.ivSize;if(buffer.length<ivSize){return fail(`buffer is too short to get iv, len=${buffer.length} dump=${buffer.toString('hex')}`)}const iv=buffer.slice(0,ivSize);const decipher=_crypto2.default.createDecipheriv(cipherName,key,iv);return Buffer.concat([decipher.update(buffer.slice(ivSize)),decipher.final()])}}exports.default=SsStreamCipherPreset;SsStreamCipherPreset.cipherName='';SsStreamCipherPreset.key=null;SsStreamCipherPreset.ivSize=0;