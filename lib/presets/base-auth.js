'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _crypto=require('crypto');var _crypto2=_interopRequireDefault(_crypto);var _utils=require('../utils');var _defs=require('./defs');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}const HMAC_METHODS={'md5':16,'sha1':20,'sha256':32};const DEFAULT_HASH_METHOD='sha1';class BaseAuthPreset extends _defs.IPreset{static checkParams({method=DEFAULT_HASH_METHOD}){const methods=Object.keys(HMAC_METHODS);if(!methods.includes(method)){throw Error(`base-auth 'method' must be one of [${methods}]`)}}static onInit({method=DEFAULT_HASH_METHOD}){BaseAuthPreset.hmacMethod=method;BaseAuthPreset.hmacLen=HMAC_METHODS[method];BaseAuthPreset.hmacKey=(0,_utils.EVP_BytesToKey)(__KEY__,16,16)}constructor(){super();this._cipher=null;this._decipher=null;this._isConnecting=false;this._isHeaderSent=false;this._isHeaderRecv=false;this._pending=Buffer.alloc(0);this._host=null;this._port=null;const key=BaseAuthPreset.hmacKey;const iv=(0,_utils.hash)('md5',Buffer.from(__KEY__+'base-auth'));if(__IS_CLIENT__){this._cipher=_crypto2.default.createCipheriv('aes-128-cfb',key,iv)}else{this._decipher=_crypto2.default.createDecipheriv('aes-128-cfb',key,iv)}}onDestroy(){this._cipher=null;this._decipher=null;this._pending=null;this._host=null;this._port=null}onNotified(action){if(__IS_CLIENT__&&action.type===_defs.CONNECT_TO_REMOTE){var _action$payload=action.payload;const host=_action$payload.host,port=_action$payload.port;this._host=Buffer.from(host);this._port=(0,_utils.numberToBuffer)(port)}}clientOut({buffer}){if(!this._isHeaderSent){this._isHeaderSent=true;const hmacMethod=BaseAuthPreset.hmacMethod,hmacKey=BaseAuthPreset.hmacKey;const header=Buffer.concat([(0,_utils.numberToBuffer)(this._host.length,1),this._host,this._port]);const encHeader=this._cipher.update(header);const mac=(0,_utils.hmac)(hmacMethod,hmacKey,encHeader);return Buffer.concat([encHeader,mac,buffer])}else{return buffer}}serverIn({buffer,next,broadcast,fail}){if(!this._isHeaderRecv){const hmacMethod=BaseAuthPreset.hmacMethod,hmacLen=BaseAuthPreset.hmacLen,hmacKey=BaseAuthPreset.hmacKey;if(this._isConnecting){this._pending=Buffer.concat([this._pending,buffer]);return}if(buffer.length<31){return fail(`length is too short: ${buffer.length}, dump=${buffer.toString('hex')}`)}const alen=this._decipher.update(buffer.slice(0,1))[0];if(buffer.length<=1+alen+2+hmacLen){return fail(`unexpected length: ${buffer.length}, dump=${buffer.toString('hex')}`)}const givenHmac=buffer.slice(1+alen+2,1+alen+2+hmacLen);const expHmac=(0,_utils.hmac)(hmacMethod,hmacKey,buffer.slice(0,1+alen+2));if(!givenHmac.equals(expHmac)){return fail(`unexpected HMAC=${givenHmac.toString('hex')} want=${expHmac.toString('hex')} dump=${buffer.slice(0,60).toString('hex')}`)}const plaintext=this._decipher.update(buffer.slice(1,1+alen+2));const addr=plaintext.slice(0,alen);const port=plaintext.slice(alen,alen+2);const data=buffer.slice(1+alen+2+hmacLen);this._isConnecting=true;broadcast({type:_defs.CONNECT_TO_REMOTE,payload:{host:addr.toString(),port:port.readUInt16BE(0),onConnected:()=>{next(data);this._isHeaderRecv=true;this._isConnecting=false;this._pending=null}}})}else{return buffer}}}exports.default=BaseAuthPreset;BaseAuthPreset.hmacMethod=DEFAULT_HASH_METHOD;BaseAuthPreset.hmacLen=null;BaseAuthPreset.hmacKey=null;