'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();var _zlib=require('zlib');var _zlib2=_interopRequireDefault(_zlib);var _defs=require('./defs');var _utils=require('../utils');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}const factories={'gzip':[_zlib2.default.gzipSync,_zlib2.default.gunzipSync],'deflate':[_zlib2.default.deflateSync,_zlib2.default.inflateSync]};const DEFAULT_METHOD='deflate';const DEFAULT_THRESHOLD='5kb';const DEFAULT_OPTIONS={};function parseSize(size){const regex=/^(\d+)(b|k|kb|m|mb)$/g;const results=regex.exec(size.toLowerCase());if(results!==null){var _results=_slicedToArray(results,3);const num=_results[1],unit=_results[2];return+num*{'b':1,'k':1024,'kb':1024,'m':1048576,'mb':1048576}[unit]}return null}class ExpCompressPreset extends _defs.IPreset{static checkParams({method=DEFAULT_METHOD,threshold=DEFAULT_THRESHOLD}){const methods=Object.keys(factories);if(!methods.includes(method)){throw Error(`'method' must be one of [${methods}]`)}const minSize=parseSize(threshold);if(minSize===null){throw Error(`'threshold': ${threshold} is invalid`)}if(minSize<1024){_utils.logger.warn('compress chunk less than 1kb can be inefficient')}}constructor({method=DEFAULT_METHOD,threshold=DEFAULT_THRESHOLD,options=DEFAULT_OPTIONS}){super();this._method='';this._threshold=0;this._options={};this._adBuf=null;this._isTransferSSL=false;this._outBytesA=0;this._outBytesB=0;this._method=method;this._threshold=parseSize(threshold);this._options=options;this._adBuf=new _utils.AdvancedBuffer({getPacketLength:this.onReceiving.bind(this)});this._adBuf.on('data',this.onReceived.bind(this))}onNotified(action){switch(action.type){case _defs.CONNECT_TO_REMOTE:this._isTransferSSL=[22,443].includes(action.payload.port);break;case _defs.CONNECTION_CLOSED:_utils.logger.debug(`overall compression ratio: ${this._outBytesB/this._outBytesA}`);break;default:break;}}beforeOut({buffer,fail}){const chunks=(0,_utils.getChunks)(buffer,32767).map(chunk=>{this._outBytesA+=chunk.length+2;let _data=chunk;let _len=chunk.length;if(chunk.length>this._threshold&&!this._isTransferSSL){try{const compressed=this.compress(buffer);if(compressed.length<32767){_data=compressed;_len=_data.length|32768}}catch(err){fail(`cannot compress chunk: ${err.message}`)}}return Buffer.concat([(0,_utils.numberToBuffer)(_len),_data])});const data=Buffer.concat(chunks);this._outBytesB+=data.length;return data}beforeIn({buffer,next,fail}){this._adBuf.put(buffer,{next,fail})}onReceiving(buffer){if(buffer.length<2){return}return 2+(buffer.readUInt16BE(0)&32767)}onReceived(chunk,{next,fail}){var _this=this;return _asyncToGenerator(function*(){const len=chunk.readUInt16BE(0);const data=chunk.slice(2);if(len>>15===1){try{next(_this.decompress(data))}catch(err){fail(`cannot decompress chunk: ${err.message}`)}}else{next(data)}})()}compress(buffer){return factories[this._method][0](buffer,this._options)}decompress(buffer){return factories[this._method][1](buffer,this._options)}}exports.default=ExpCompressPreset;