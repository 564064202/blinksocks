'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Socket=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();/* eslint-disable no-undef */var _net=require('net');var _net2=_interopRequireDefault(_net);var _Address=require('../Address');var _DNSCache=require('../DNSCache');var _Pipe=require('../Pipe');var _Middlewares=require('../Middlewares');var _utils=require('../../utils');var _constants=require('../../constants');var _socks=require('../../proxies/socks5');var _socks2=require('../../proxies/socks4');var _http=require('../../proxies/http');var _common=require('../../proxies/common');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i]}return arr2}else{return Array.from(arr)}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var Logger=require('../../utils/logger')(__filename);var dnsCache=_DNSCache.DNSCache.create();var Socket=exports.Socket=function(){function Socket(_ref){var _this=this;var id=_ref.id,socket=_ref.socket;_classCallCheck(this,Socket);this._id=null;this._bsocket=null;this._fsocket=null;this._socksTcpReady=false;this._socksUdpReady=false;this._httpReady=false;this._targetAddress=null;this._pipeForward=null;this._pipeBackward=null;Logger.setLevel(__LOG_LEVEL__);this._id=id;this._bsocket=socket;// handle events
this._bsocket.on('error',function(err){return _this.onError(err)});this._bsocket.on('close',function(had_error){return _this.onClose(had_error)});this._bsocket.on('data',function(buffer){return _this.onForward(buffer)});if(__IS_SERVER__){this.createPipes()}}_createClass(Socket,[{key:'isHandshakeDone',value:function isHandshakeDone(){return[this._socksTcpReady,this._socksUdpReady,this._httpReady].some(function(v){return!!v})}},{key:'onForward',value:function onForward(buffer){var _this2=this;if(__IS_CLIENT__&&!this.isHandshakeDone()){// client handshake(multiple-protocols), client only
this.onHandshake(buffer);return}var _buffer=buffer;// udp compatible
if(__IS_CLIENT__&&this._socksUdpReady){var request=_socks.UdpRequestMessage.parse(buffer);if(request!==null){// just drop RSV and FRAG
_buffer=request.DATA}else{if(Logger.isWarnEnabled()){Logger.warn('['+this._id+'] -x-> dropped unidentified packet '+buffer.length+' bytes')}return}}this._pipeForward.feed(_buffer).then(function(buf){return _this2._fsocket.write(buf)}).catch(function(err){return Logger.error(err.message)})}},{key:'onBackward',value:function onBackward(buffer){var _this3=this;this._pipeBackward.feed(buffer).then(function(buf){return _this3._bsocket.write(buf)}).catch(function(err){return Logger.error(err)})}},{key:'onError',value:function onError(err){switch(err.code){case'ECONNREFUSED':case'EADDRNOTAVAIL':case'ENETDOWN':case'ECONNRESET':case'ETIMEDOUT':case'EAI_AGAIN':case'EPIPE':Logger.warn('['+this._id+'] '+err.message);return;default:Logger.error(err);break;}this.onClose(true)}},{key:'onClose',value:function onClose(had_error){if(had_error){Logger.warn('client['+this._id+'] closed due to a transmission error')}else{Logger.info('client['+this._id+'] closed normally')}if(this._bsocket!==null&&!this._bsocket.destroyed){this._bsocket.end();this._bsocket=null}if(this._fsocket!==null&&!this._fsocket.destroyed){this._fsocket.end();this._fsocket=null}}/**
   * TODO(refactor): too redundant
   * create pipes for both data forward and backward
   */},{key:'createPipes',value:function createPipes(){var _this4=this;if(__IS_CLIENT__){(function(){// forward
var props_1={direction:_Middlewares.MIDDLEWARE_DIRECTION_UPWARD};var props_2={direction:_Middlewares.MIDDLEWARE_DIRECTION_DOWNWARD};var fcrypto=new _Middlewares.CryptoMiddleware(props_1);var bcrypto=new _Middlewares.CryptoMiddleware(props_2);_this4._pipeForward=new _Pipe.Pipe({onNotify:function onNotify(action){switch(action.type){case _constants.CRYPTO_SET_IV_AFTER:{var iv=action.payload;fcrypto.deferUpdateCiphers(iv);bcrypto.updateCiphers(iv);break}default:return false;}return true}});_this4._pipeForward.pipe(new _Middlewares.FrameMiddleware(_extends({},props_1,{address:_this4._targetAddress}))).pipe(new _Middlewares.ProtocolMiddleware(props_1)).pipe(fcrypto).pipe(new _Middlewares.ObfsMiddleware(props_1));// backward
_this4._pipeBackward=new _Pipe.Pipe;_this4._pipeBackward.pipe(new _Middlewares.ObfsMiddleware(props_2)).pipe(bcrypto).pipe(new _Middlewares.ProtocolMiddleware(props_2)).pipe(new _Middlewares.FrameMiddleware(props_2))})()}if(__IS_SERVER__){(function(){// forward
var props_1={direction:_Middlewares.MIDDLEWARE_DIRECTION_DOWNWARD};var props_2={direction:_Middlewares.MIDDLEWARE_DIRECTION_UPWARD};var fcrypto=new _Middlewares.CryptoMiddleware(props_1);var bcrypto=new _Middlewares.CryptoMiddleware(props_2);_this4._pipeForward=new _Pipe.Pipe({onNotify:function onNotify(action){switch(action.type){case _constants.CRYPTO_SET_IV:{var iv=action.payload;fcrypto.updateCiphers(iv);bcrypto.updateCiphers(iv);break}case _constants.SOCKET_CONNECT_TO_DST:_this4.connectToDst.apply(_this4,_toConsumableArray(action.payload));break;default:return false;}return true}});_this4._pipeForward.pipe(new _Middlewares.ObfsMiddleware(props_1)).pipe(fcrypto).pipe(new _Middlewares.ProtocolMiddleware(props_1)).pipe(new _Middlewares.FrameMiddleware(props_1));// backward
_this4._pipeBackward=new _Pipe.Pipe;_this4._pipeBackward.pipe(new _Middlewares.FrameMiddleware(props_2)).pipe(new _Middlewares.ProtocolMiddleware(props_2)).pipe(bcrypto).pipe(new _Middlewares.ObfsMiddleware(props_2))})()}}/**
   * connect to blinksocks server
   * @returns {Promise}
   */},{key:'connectToServer',value:function connectToServer(){var _this5=this;return new Promise(function(resolve,reject){_this5._fsocket=_net2.default.connect({host:__SERVER_HOST__,port:__SERVER_PORT__});_this5._fsocket.on('connect',function(){_this5.createPipes();resolve()});_this5._fsocket.on('error',function(err){return reject(err)});_this5._fsocket.on('close',function(had_error){return _this5.onClose(had_error)});_this5._fsocket.on('data',function(buffer){return _this5.onBackward(buffer)})})}/**
   * connect to the real server, server side only
   * @param address
   * @param callback
   * @returns {Promise.<void>}
   */},{key:'connectToDst',value:function(){var _ref2=_asyncToGenerator(regeneratorRuntime.mark(function _callee(address,callback){var _this6=this;var _address$getEndPoint,_address$getEndPoint2,host,port,ip;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_address$getEndPoint=address.getEndPoint(),_address$getEndPoint2=_slicedToArray(_address$getEndPoint,2),host=_address$getEndPoint2[0],port=_address$getEndPoint2[1];_context.next=3;return dnsCache.get(host);case 3:ip=_context.sent;this._fsocket=_net2.default.connect({host:ip,port:port},callback);this._fsocket.on('error',function(err){return _this6.onError(err)});this._fsocket.on('close',function(had_error){return _this6.onClose(had_error)});this._fsocket.on('data',function(buffer){return _this6.onBackward(buffer)});case 8:case'end':return _context.stop();}}},_callee,this)}));function connectToDst(_x,_x2){return _ref2.apply(this,arguments)}return connectToDst}()/*** client handshake, multiple protocols ***/},{key:'onHandshake',value:function onHandshake(buffer){this.trySocksHandshake(this._bsocket,buffer);if(!this.isHandshakeDone()){this.tryHttpHandshake(this._bsocket,buffer)}}},{key:'onHandshakeDone',value:function onHandshakeDone(callback){this.connectToServer().then(callback).catch(this.onError.bind(this))}},{key:'trySocksHandshake',value:function trySocksHandshake(socket,buffer){if(!this.isHandshakeDone()){this.trySocks5Handshake(socket,buffer)}if(!this.isHandshakeDone()){this.trySocks4Handshake(socket,buffer)}}},{key:'trySocks4Handshake',value:function trySocks4Handshake(socket,buffer){var _this7=this;var request=_socks2.RequestMessage.parse(buffer);if(request!==null){var CMD=request.CMD,DSTIP=request.DSTIP,DSTADDR=request.DSTADDR,DSTPORT=request.DSTPORT;if(CMD===_common.REQUEST_COMMAND_CONNECT){this._targetAddress=new _Address.Address({ATYP:DSTADDR.length>0?_common.ATYP_DOMAIN:_common.ATYP_V4,DSTADDR:DSTADDR.length>0?DSTADDR:DSTIP,DSTPORT:DSTPORT});this.onHandshakeDone(function(){// reply success
var message=new _socks2.ReplyMessage({CMD:_common.REPLY_GRANTED});socket.write(message.toBuffer());_this7._socksTcpReady=true})}}}},{key:'trySocks5Handshake',value:function trySocks5Handshake(socket,buffer){var _this8=this;// 1. IDENTIFY
var identifier=_socks.IdentifierMessage.parse(buffer);if(identifier!==null){var message=new _socks.SelectMessage;socket.write(message.toBuffer());return}// 2. REQUEST
var request=_socks.RequestMessage.parse(buffer);if(request!==null){(function(){var type=request.CMD;switch(type){case _common.REQUEST_COMMAND_UDP:// UDP ASSOCIATE
case _common.REQUEST_COMMAND_CONNECT:{_this8._targetAddress=new _Address.Address({ATYP:request.ATYP,DSTADDR:request.DSTADDR,DSTPORT:request.DSTPORT});_this8.onHandshakeDone(function(){// reply success
var message=new _socks.ReplyMessage({REP:_common.REPLY_SUCCEEDED});socket.write(message.toBuffer());if(type===_common.REQUEST_COMMAND_CONNECT){_this8._socksTcpReady=true}else{_this8._socksUdpReady=true}});break}default:{var _message=new _socks.ReplyMessage({REP:_common.REPLY_COMMAND_NOT_SUPPORTED});socket.write(_message.toBuffer());break}}})()}}},{key:'tryHttpHandshake',value:function tryHttpHandshake(socket,buffer){var request=_http.HttpRequestMessage.parse(buffer);if(request!==null){var METHOD=request.METHOD,HOST=request.HOST;this._targetAddress=_utils.Utils.hostToAddress(HOST.toString());this._httpReady=true;if(METHOD.toString()==='CONNECT'){this.onHandshakeDone(function(){var message=new _http.ConnectReplyMessage;socket.write(message.toBuffer())})}else{// for clients who haven't sent CONNECT, should begin to relay immediately
this.onReceiving(socket,buffer)}}}}]);return Socket}();