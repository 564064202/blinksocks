'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Relay=undefined;var _events=require('events');var _events2=_interopRequireDefault(_events);var _net=require('net');var _net2=_interopRequireDefault(_net);var _tls=require('tls');var _tls2=_interopRequireDefault(_tls);var _actionHandler=require('./action-handler');var _actionHandler2=_interopRequireDefault(_actionHandler);var _pipe=require('./pipe');var _dnsCache=require('./dns-cache');var _middleware=require('./middleware');var _utils=require('../utils');var _defs=require('../presets/defs');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}const MAX_BUFFERED_SIZE=512*1024;class Relay extends _events2.default{constructor({socket}){super();this._dnsCache=null;this._isConnectedToRemote=false;this._remoteHost='';this._remotePort='';this._bsocket=null;this._fsocket=null;this._pipe=null;this._presets=[];this.onForward=this.onForward.bind(this);this.onBackward=this.onBackward.bind(this);this.onError=this.onError.bind(this);this.onBackwardSocketTimeout=this.onBackwardSocketTimeout.bind(this);this.onBackwardSocketClose=this.onBackwardSocketClose.bind(this);this.onForwardSocketTimeout=this.onForwardSocketTimeout.bind(this);this.onForwardSocketClose=this.onForwardSocketClose.bind(this);this.sendForward=this.sendForward.bind(this);this.sendBackward=this.sendBackward.bind(this);this.connect=this.connect.bind(this);this.setPresets=this.setPresets.bind(this);this.destroy=this.destroy.bind(this);this._dnsCache=new _dnsCache.DNSCache({expire:__DNS_EXPIRE__});this._remoteHost=socket.remoteAddress;this._remotePort=socket.remotePort;this._bsocket=socket;this._bsocket.on('error',this.onError);this._bsocket.on('close',this.onBackwardSocketClose);this._bsocket.on('timeout',this.onBackwardSocketTimeout.bind(this,{host:this._remoteHost,port:this._remotePort}));this._bsocket.on('data',this.onForward);this._bsocket.setTimeout(__TIMEOUT__);let presets=__PRESETS__;if(__IS_CLIENT__&&!['proxy','tunnel'].includes(presets[0].name)){presets=[{name:'proxy'}].concat(presets)}if(presets[presets.length-1].name!=='tracker'){presets=presets.concat([{name:'tracker'}])}this._presets=presets;this._pipe=this.createPipe(presets);this._pipe.broadcast('pipe',{type:_defs.CONNECTION_CREATED,payload:{host:this._remoteHost,port:this._remotePort}})}get remote(){return`${this._remoteHost}:${this._remotePort}`}get fsocketWritable(){return this._fsocket&&!this._fsocket.destroyed&&this._fsocket.writable}get bsocketWritable(){return this._bsocket&&!this._bsocket.destroyed&&this._bsocket.writable}onError(err){_utils.logger.warn(`[relay] [${this.remote}] ${err.code||''} - ${err.message}`)}onForward(buffer){if(this.fsocketWritable||!this._isConnectedToRemote){const direction=__IS_CLIENT__?_middleware.MIDDLEWARE_DIRECTION_UPWARD:_middleware.MIDDLEWARE_DIRECTION_DOWNWARD;this._pipe.feed(direction,buffer)}if(this._fsocket&&this._fsocket.bufferSize>=MAX_BUFFERED_SIZE){_utils.logger.debug(`[relay] bsocket recv paused due to fsocket.bufferSize=${this._fsocket.bufferSize} > ${MAX_BUFFERED_SIZE}`);this._bsocket.pause();this._fsocket.once('drain',()=>{if(this._bsocket&&!this._bsocket.destroyed){_utils.logger.debug('[relay] bsocket resume to recv');this._bsocket.resume()}})}}onForwardSocketTimeout({host,port}){_utils.logger.warn(`[relay] [${host}:${port}] timeout: no I/O on the connection for ${__TIMEOUT__/1e3}s`);this.onForwardSocketClose()}onForwardSocketClose(){if(this._fsocket){this._fsocket.destroy();this._fsocket=null}if(this._bsocket){const bufferSize=this._bsocket.bufferSize-(__IS_TLS__?1:0);if(bufferSize>0){this._bsocket.once('drain',this.onBackwardSocketClose)}else{this.onBackwardSocketClose()}}}onBackward(buffer){if(this.bsocketWritable){const direction=__IS_CLIENT__?_middleware.MIDDLEWARE_DIRECTION_DOWNWARD:_middleware.MIDDLEWARE_DIRECTION_UPWARD;this._pipe.feed(direction,buffer)}if(this._bsocket&&this._bsocket.bufferSize>=MAX_BUFFERED_SIZE){_utils.logger.debug(`[relay] fsocket recv paused due to bsocket.bufferSize=${this._bsocket.bufferSize} > ${MAX_BUFFERED_SIZE}`);this._fsocket.pause();this._bsocket.once('drain',()=>{if(this._fsocket&&!this._fsocket.destroyed){_utils.logger.debug('[relay] fsocket resume to recv');this._fsocket.resume()}})}}onBackwardSocketTimeout({host,port}){_utils.logger.warn(`[relay] [${host}:${port}] timeout: no I/O on the connection for ${__TIMEOUT__/1e3}s`);this.onBackwardSocketClose()}onBackwardSocketClose(){if(this._bsocket){this._bsocket.destroy();this._bsocket=null;this._pipe.broadcast('pipe',{type:_defs.CONNECTION_CLOSED,payload:{host:this._remoteHost,port:this._remotePort}});this._pipe.destroy();this._pipe=null;this.emit('close')}if(this._fsocket){const bufferSize=this._fsocket.bufferSize-(__IS_TLS__?1:0);if(bufferSize>0){this._fsocket.once('drain',this.onForwardSocketClose)}else{this.onForwardSocketClose()}}}sendForward(buffer){if(__IS_CLIENT__){this.fsocketWritable&&this._fsocket.write(buffer)}else{this.bsocketWritable&&this._bsocket.write(buffer)}}sendBackward(buffer){if(__IS_CLIENT__){this.bsocketWritable&&this._bsocket.write(buffer)}else{this.fsocketWritable&&this._fsocket.write(buffer)}}connect({host,port}){var _this=this;return _asyncToGenerator(function*(){if(!(0,_utils.isValidHostname)(host)||!(0,_utils.isValidPort)(port)){_utils.logger.warn(`unexpected host=${host} port=${port}`);_this.onBackwardSocketClose();return}let ip=null;try{ip=yield _this._dnsCache.get(host)}catch(err){_utils.logger.error(`[relay] [${_this.remote}] fail to resolve host ${host}:${port}: ${err.message}`)}_utils.logger.info(`[relay] [${_this.remote}] connecting to: ${host}(${ip}):${port}`);return new Promise(function(resolve){if(_this._fsocket&&!_this._fsocket.destroyed){_this._fsocket.destroy();_this._fsocket=null}if(__IS_CLIENT__&&__IS_TLS__){_this._fsocket=_tls2.default.connect({host,port,ca:[__TLS_CERT__]},function(){return resolve(_this._fsocket)})}else{_this._fsocket=_net2.default.connect({host:ip,port},function(){return resolve(_this._fsocket)})}_this._fsocket.on('error',_this.onError);_this._fsocket.on('close',_this.onForwardSocketClose);_this._fsocket.on('timeout',_this.onForwardSocketTimeout.bind(_this,{host,port}));_this._fsocket.on('data',_this.onBackward);_this._fsocket.setTimeout(__TIMEOUT__)})})()}setPresets(callback){this._presets=callback(this._presets);this._pipe.destroy();this._pipe=this.createPipe(this._presets)}createPipe(presets){const middlewares=presets.map(preset=>(0,_middleware.createMiddleware)(preset.name,preset.params||{}));const pipe=new _pipe.Pipe;pipe.on('broadcast',_actionHandler2.default.bind(this));pipe.on(`next_${_middleware.MIDDLEWARE_DIRECTION_UPWARD}`,this.sendForward);pipe.on(`next_${_middleware.MIDDLEWARE_DIRECTION_DOWNWARD}`,this.sendBackward);pipe.setMiddlewares(middlewares);return pipe}destroy(){this.onForwardSocketClose();this.onBackwardSocketClose()}}exports.Relay=Relay;