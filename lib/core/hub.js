'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Hub=undefined;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};var _cluster=require('cluster');var _cluster2=_interopRequireDefault(_cluster);var _dgram=require('dgram');var _dgram2=_interopRequireDefault(_dgram);var _net=require('net');var _net2=_interopRequireDefault(_net);var _tls=require('tls');var _tls2=_interopRequireDefault(_tls);var _ws=require('ws');var _ws2=_interopRequireDefault(_ws);var _lruCache=require('lru-cache');var _lruCache2=_interopRequireDefault(_lruCache);var _balancer=require('./balancer');var _config=require('./config');var _relay=require('./relay');var _muxRelay=require('./mux-relay');var _utils=require('../utils');var _proxies=require('../proxies');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}class Hub{constructor(config){this._wkId=_cluster2.default.worker?_cluster2.default.worker.id:0;this._tcpServer=null;this._udpServer=null;this._tcpRelays=new Map;this._muxRelays=new Map;this._udpRelays=null;_config.Config.init(config);this._onConnection=this._onConnection.bind(this);this._udpRelays=(0,_lruCache2.default)({max:500,dispose:(key,relay)=>relay.destroy(),maxAge:1e5})}terminate(callback){this._udpRelays.reset();if(__MUX__){this._muxRelays.forEach(relay=>relay.destroy());this._muxRelays.clear()}this._tcpRelays.forEach(relay=>relay.destroy());this._tcpRelays.clear();if(__IS_CLIENT__){_balancer.Balancer.destroy();_utils.logger.info(`[balancer-${this._wkId}] stopped`)}this._tcpServer.close();_utils.logger.info(`[hub-${this._wkId}] shutdown`);this._udpServer.close();typeof callback==='function'&&callback()}run(){var _this=this;return _asyncToGenerator(function*(){if(_this._tcpServer!==null){_this.terminate()}if(__IS_CLIENT__){_balancer.Balancer.start(__SERVERS__);_utils.logger.info(`[balancer-${_this._wkId}] started`);_this._switchServer()}try{yield _this._createServer()}catch(err){_utils.logger.error('[hub] fail to create server:',err);process.exit(-1)}})()}_createServer(){var _this2=this;return _asyncToGenerator(function*(){if(__IS_CLIENT__){_this2._tcpServer=yield _this2._createServerOnClient()}else{_this2._tcpServer=yield _this2._createServerOnServer()}_this2._udpServer=yield _this2._createUdpServer()})()}_createServerOnClient(){var _this3=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){let server=null;switch(__LOCAL_PROTOCOL__){case'tcp':server=_proxies.tcp.createServer({forwardHost:__FORWARD_HOST__,forwardPort:__FORWARD_PORT__});break;case'socks':case'socks5':case'socks4':case'socks4a':server=_proxies.socks.createServer({bindAddress:__LOCAL_HOST__,bindPort:__LOCAL_PORT__});break;case'http':case'https':server=_proxies.http.createServer();break;default:return reject(Error(`unsupported protocol: "${__LOCAL_PROTOCOL__}"`));}const address={host:__LOCAL_HOST__,port:__LOCAL_PORT__};server.on('proxyConnection',_this3._onConnection);server.listen(address,function(){const service=`${__LOCAL_PROTOCOL__}://${__LOCAL_HOST__}:${__LOCAL_PORT__}`;_utils.logger.info(`[hub-${_this3._wkId}] blinksocks client is running at ${service}`);resolve(server)})})})()}_createServerOnServer(){var _this4=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){const address={host:__LOCAL_HOST__,port:__LOCAL_PORT__};const onListening=function onListening(server){const service=`${__LOCAL_PROTOCOL__}://${__LOCAL_HOST__}:${__LOCAL_PORT__}`;_utils.logger.info(`[hub-${_this4._wkId}] blinksocks server is running at ${service}`);resolve(server)};switch(__LOCAL_PROTOCOL__){case'tcp':{const server=_net2.default.createServer();server.on('connection',_this4._onConnection);server.listen(address,function(){return onListening(server)});break}case'ws':{const server=new _ws2.default.Server(_extends({},address,{perMessageDeflate:false}));server.on('connection',function(ws,req){ws.remoteAddress=req.connection.remoteAddress;ws.remotePort=req.connection.remotePort;_this4._onConnection(ws)});server.on('listening',function(){return onListening(server)});break}case'tls':{const server=_tls2.default.createServer({key:[__TLS_KEY__],cert:[__TLS_CERT__]});server.on('secureConnection',_this4._onConnection);server.listen(address,function(){return onListening(server)});break}default:return reject(Error(`unsupported protocol: "${__LOCAL_PROTOCOL__}"`));}})})()}_createUdpServer(){var _this5=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){const relays=_this5._udpRelays;const server=_dgram2.default.createSocket('udp4');server.on('message',function(msg,rinfo){const address=rinfo.address,port=rinfo.port;let proxyRequest=null;let packet=msg;if(__IS_CLIENT__){const parsed=_proxies.socks.parseSocks5UdpRequest(msg);if(parsed===null){_utils.logger.warn(`[hub] [${address}:${port}] drop invalid udp packet: ${(0,_utils.dumpHex)(msg)}`);return}const host=parsed.host,port=parsed.port,data=parsed.data;proxyRequest={host,port};packet=data}const key=`${address}:${port}`;let relay=relays.get(key);if(relay===undefined){const context={socket:server,remoteInfo:{host:address,port:port}};relay=_this5._createUdpRelay(context);relay.init({proxyRequest});relay.on('close',function onRelayClose(){});relays.set(key,relay);relays.prune()}if(relay._inbound){relay._inbound.onReceive(packet,rinfo)}});server.on('error',reject);server.close=function(){return function(...args){}}(server.close);if(__IS_CLIENT__){server.send=function(send){return function(data,port,host,isSs,...args){let packet=null;if(isSs){packet=Buffer.from([0,0,0,...data])}else{packet=_proxies.socks.encodeSocks5UdpResponse({host,port,data})}send.call(server,packet,port,host,...args)}}(server.send)}server.bind({address:__LOCAL_HOST__,port:__LOCAL_PORT__},function(){const service=`udp://${__LOCAL_HOST__}:${__LOCAL_PORT__}`;_utils.logger.info(`[hub-${_this5._wkId}] blinksocks udp server is running at ${service}`);resolve(server)})})})()}_onConnection(socket,proxyRequest=null){_utils.logger.verbose(`[hub] [${socket.remoteAddress}:${socket.remotePort}] connected`);if(__IS_CLIENT__){this._switchServer()}const context={socket,proxyRequest,remoteInfo:{host:socket.remoteAddress,port:socket.remotePort}};let muxRelay=null;if(__MUX__){if(__IS_CLIENT__){muxRelay=this.getMuxRelay()||this._createMuxRelay(context);if(!muxRelay.isOutboundReady()){muxRelay.init({proxyRequest})}else{proxyRequest.onConnected()}Object.assign(context,{muxRelay})}else{Object.assign(context,{getMuxRelay:this.getMuxRelay.bind(this)})}}const relay=this._createRelay(context);relay.init({proxyRequest});relay.on('close',()=>this.onRelayClose(relay));if(__MUX__){if(__IS_CLIENT__){muxRelay.addSubRelay(relay)}else{this._muxRelays.set(relay.id,relay)}}this._tcpRelays.set(relay.id,relay)}_createRelay(context){const props={context:context,transport:__TRANSPORT__,presets:__PRESETS__};if(__MUX__){if(__IS_CLIENT__){return new _relay.Relay(_extends({},props,{transport:'mux',presets:[]}))}else{return new _muxRelay.MuxRelay(props)}}else{return new _relay.Relay(props)}}_createUdpRelay(context){return new _relay.Relay({transport:'udp',context,presets:__UDP_PRESETS__})}_createMuxRelay(context){const relay=new _muxRelay.MuxRelay({transport:__TRANSPORT__,context,presets:__PRESETS__});relay.on('close',()=>this.onRelayClose(relay));this._muxRelays.set(relay.id,relay);_utils.logger.info(`[mux-${relay.id}] create mux connection, total: ${this._muxRelays.size}`);return relay}getMuxRelay(){const relays=this._muxRelays;const concurrency=relays.size;if(concurrency<1){return null}if(__IS_CLIENT__&&concurrency<__MUX_CONCURRENCY__&&(0,_utils.getRandomInt)(0,1)===0){return null}return relays.get([...relays.keys()][(0,_utils.getRandomInt)(0,concurrency-1)])}onRelayClose(relay){if(relay instanceof _muxRelay.MuxRelay){relay.destroy()}if(__MUX__&&__IS_CLIENT__){const ctx=relay.getContext();if(ctx&&ctx.muxRelay){ctx.muxRelay.destroySubRelay(relay.id)}}this._tcpRelays.delete(relay.id);this._muxRelays.delete(relay.id)}_switchServer(){const server=_balancer.Balancer.getFastest();if(server){_config.Config.initServer(server);_utils.logger.info(`[balancer-${this._wkId}] use server: ${__SERVER_HOST__}:${__SERVER_PORT__}`)}}}exports.Hub=Hub;