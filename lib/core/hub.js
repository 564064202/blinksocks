'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Hub=undefined;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};var _cluster=require('cluster');var _cluster2=_interopRequireDefault(_cluster);var _dgram=require('dgram');var _dgram2=_interopRequireDefault(_dgram);var _net=require('net');var _net2=_interopRequireDefault(_net);var _tls=require('tls');var _tls2=_interopRequireDefault(_tls);var _ws=require('ws');var _ws2=_interopRequireDefault(_ws);var _lruCache=require('lru-cache');var _lruCache2=_interopRequireDefault(_lruCache);var _balancer=require('./balancer');var _config=require('./config');var _middleware=require('./middleware');var MiddlewareManager=_interopRequireWildcard(_middleware);var _relay=require('./relay');var _utils=require('../utils');var _proxies=require('../proxies');function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key]}}newObj.default=obj;return newObj}}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}class Hub{constructor(config){this._isFirstWorker=_cluster2.default.worker?_cluster2.default.worker.id<=1:true;this._fastestServer=null;this._server=null;this._udpServer=null;this._relays=[];this._udpRelays=null;this._onConnection=this._onConnection.bind(this);if(config!==undefined){_config.Config.init(config)}this._udpRelays=(0,_lruCache2.default)({max:500,dispose:(key,relay)=>relay.destroy(),maxAge:1e5})}terminate(callback){this._udpRelays.reset();this._relays.forEach(relay=>relay.destroy());MiddlewareManager.cleanup();if(__IS_CLIENT__){_balancer.Balancer.destroy();this._isFirstWorker&&_utils.logger.info('[balancer] stopped')}this._server.close();this._isFirstWorker&&_utils.logger.info('[hub] shutdown');this._udpServer.close();typeof callback==='function'&&callback()}run(){var _this=this;return _asyncToGenerator(function*(){if(_this._server!==null){_this.terminate()}if(__IS_CLIENT__){_balancer.Balancer.start(__SERVERS__);_this._isFirstWorker&&_utils.logger.info('[balancer] started');_this._selectServer()}yield _this._createServer()})()}_createServer(){var _this2=this;return _asyncToGenerator(function*(){try{if(__IS_CLIENT__){_this2._server=yield _this2._createServerOnClient()}else{_this2._server=yield _this2._createServerOnServer()}_this2._udpServer=yield _this2._createUdpServer()}catch(err){_utils.logger.error('[hub] fail to create server:',err);process.exit(-1)}})()}_createServerOnClient(){var _this3=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){let server=null;switch(__LOCAL_PROTOCOL__){case'tcp':server=_proxies.tcp.createServer();break;case'socks':case'socks5':case'socks4':case'socks4a':server=_proxies.socks.createServer({bindAddress:__LOCAL_HOST__,bindPort:__LOCAL_PORT__});break;case'http':case'https':server=_proxies.http.createServer();break;default:return reject(Error(`unsupported protocol: "${__LOCAL_PROTOCOL__}"`));}const address={host:__LOCAL_HOST__,port:__LOCAL_PORT__};server.on('proxyConnection',_this3._onConnection);server.listen(address,function(){return resolve(server)});if(_this3._isFirstWorker){_utils.logger.info(`[hub] blinksocks client is running at ${__LOCAL_PROTOCOL__}://${__LOCAL_HOST__}:${__LOCAL_PORT__}`)}})})()}_createServerOnServer(){var _this4=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){const address={host:__LOCAL_HOST__,port:__LOCAL_PORT__};switch(__LOCAL_PROTOCOL__){case'tcp':{const server=_net2.default.createServer();server.on('connection',_this4._onConnection);server.listen(address,function(){return resolve(server)});break}case'ws':{const server=new _ws2.default.Server(_extends({},address,{perMessageDeflate:false}));server.on('connection',function(ws,req){ws.remoteAddress=req.connection.remoteAddress;ws.remotePort=req.connection.remotePort;_this4._onConnection(ws)});server.on('listening',function(){return resolve(server)});break}case'tls':{const server=_tls2.default.createServer({key:[__TLS_KEY__],cert:[__TLS_CERT__]});server.on('secureConnection',_this4._onConnection);server.listen(address,function(){return resolve(server)});break}default:return reject(Error(`unsupported protocol: "${__LOCAL_PROTOCOL__}"`));}if(_this4._isFirstWorker){_utils.logger.info(`[hub] blinksocks server is running at ${__LOCAL_PROTOCOL__}://${__LOCAL_HOST__}:${__LOCAL_PORT__}`)}})})()}_createUdpServer(){var _this5=this;return _asyncToGenerator(function*(){return new Promise(function(resolve,reject){const relays=_this5._udpRelays;const server=_dgram2.default.createSocket('udp4');server.on('message',function(msg,rinfo){let proxyRequest=null;let packet=msg;if(__IS_CLIENT__){const parsed=_proxies.socks.parseSocks5UdpRequest(msg);if(parsed===null){_utils.logger.warn(`[hub] [${rinfo.address}:${rinfo.port}] drop invalid udp packet: ${msg.slice(0,60).toString('hex')}`);return}const host=parsed.host,port=parsed.port,data=parsed.data;proxyRequest={host,port};packet=data}const address=rinfo.address,port=rinfo.port;const key=`${address}:${port}`;let relay=relays.get(key);if(relay===undefined){server.remoteAddress=address;server.remotePort=port;relay=(0,_relay.createRelay)('udp',server,proxyRequest);relay.on('close',function onRelayClose(){});relays.set(key,relay);relays.prune()}relay._inbound.onReceive(packet,rinfo)});server.on('error',reject);server.close=function(close){return function(...args){}}(server.close);if(__IS_CLIENT__){const isShadowsocks=function isShadowsocks(){return __PRESETS__.some(({name})=>['ss-base'].includes(name))};server.send=function(send){return function(data,port,host,...args){let packet=null;if(isShadowsocks()){packet=Buffer.from([0,0,0,...data])}else{packet=_proxies.socks.encodeSocks5UdpResponse({host,port,data})}send.call(server,packet,port,host,...args)}}(server.send)}server.bind({address:__LOCAL_HOST__,port:__LOCAL_PORT__},function(){return resolve(server)});if(_this5._isFirstWorker){_utils.logger.info(`[hub] blinksocks udp server is running at udp://${__LOCAL_HOST__}:${__LOCAL_PORT__}`)}})})()}_selectServer(){const server=_balancer.Balancer.getFastest();if(this._fastestServer===null||server.id!==this._fastestServer.id){this._fastestServer=server;_config.Config.initServer(server);MiddlewareManager.reset();_utils.logger.info(`[balancer] use server: ${__SERVER_HOST__}:${__SERVER_PORT__}`)}}_onConnection(context,proxyRequest=null){if(__IS_CLIENT__){this._selectServer()}_utils.logger.verbose(`[hub] [${context.remoteAddress}:${context.remotePort}] connected`);const relay=(0,_relay.createRelay)(__TRANSPORT__,context,proxyRequest);relay.on('close',()=>{this._relays=this._relays.filter(r=>r.id!==relay.id)});this._relays.push(relay)}}exports.Hub=Hub;