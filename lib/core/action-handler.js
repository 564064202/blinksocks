'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();let onConnectToRemote=(()=>{var _ref=_asyncToGenerator(function*(action){var _action$payload=action.payload;const host=_action$payload.host,port=_action$payload.port,onConnected=_action$payload.onConnected;if(__IS_SERVER__){yield this.connect({host,port})}if(__IS_CLIENT__){_utils.logger.info(`[relay] [${this.remote}] request: ${host}:${port}`);yield this.connect({host:__SERVER_HOST__,port:__SERVER_PORT__})}this._isConnectedToRemote=true;if(typeof onConnected==='function'){onConnected()}});return function onConnectToRemote(_x){return _ref.apply(this,arguments)}})();let onPresetFailed=(()=>{var _ref2=_asyncToGenerator(function*(action){var _action$payload2=action.payload;const name=_action$payload2.name,message=_action$payload2.message;_utils.logger.error(`[relay] [${this.remote}] preset "${name}" fail to process: ${message}`);if(__IS_CLIENT__){_utils.logger.warn(`[relay] [${this.remote}] connection closed`);this.destroy()}if(__IS_SERVER__){if(__REDIRECT__){const orgData=action.payload.orgData;var _REDIRECT__$split=__REDIRECT__.split(':'),_REDIRECT__$split2=_slicedToArray(_REDIRECT__$split,2);const host=_REDIRECT__$split2[0],port=_REDIRECT__$split2[1];_utils.logger.warn(`[relay] [${this.remote}] connection is redirecting to: ${host}:${port}`);this.setPresets(function(){return[{name:'tracker'}]});const fsocket=yield this.connect({host,port:+port});if(fsocket&&fsocket.writable){fsocket.write(orgData)}}else{this._bsocket&&this._bsocket.pause();this._fsocket&&this._fsocket.pause();const timeout=(0,_utils.getRandomInt)(10,40);_utils.logger.warn(`[relay] [${this.remote}] connection will be closed in ${timeout}s...`);setTimeout(this.destroy,timeout*1e3)}}});return function onPresetFailed(_x2){return _ref2.apply(this,arguments)}})();exports.default=ActionHandler;var _utils=require('../utils');var _defs=require('../presets/defs');function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}const mapping={[_defs.CONNECT_TO_REMOTE]:onConnectToRemote,[_defs.PRESET_FAILED]:onPresetFailed,[_defs.PRESET_CLOSE_CONNECTION]:onPresetCloseConnection,[_defs.PRESET_PAUSE_RECV]:onPresetPauseRecv,[_defs.PRESET_RESUME_RECV]:onPresetResumeRecv,[_defs.PRESET_PAUSE_SEND]:onPresetPauseSend,[_defs.PRESET_RESUME_SEND]:onPresetResumeSend};function onPresetCloseConnection(){_utils.logger.info(`[relay] [${this.remote}] preset request to close connection`);this.destroy()}function onPresetPauseRecv(){__IS_SERVER__?this._bsocket&&this._bsocket.pause():this._fsocket&&this._fsocket.pause()}function onPresetResumeRecv(){__IS_SERVER__?this._bsocket&&this._bsocket.resume():this._fsocket&&this._fsocket.resume()}function onPresetPauseSend(){__IS_SERVER__?this._fsocket&&this._fsocket.pause():this._bsocket&&this._bsocket.pause()}function onPresetResumeSend(){__IS_SERVER__?this._fsocket&&this._fsocket.resume():this._bsocket&&this._bsocket.resume()}function ActionHandler(action){const handler=mapping[action.type];if(typeof handler==='function'){handler.call(this,action)}else{_utils.logger.warn(`unhandled action type: ${action.type}`)}}