'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Socket=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();var _path=require('path');var _path2=_interopRequireDefault(_path);var _log4js=require('log4js');var _log4js2=_interopRequireDefault(_log4js);var _Address=require('../Address');var _Crypto=require('../Crypto');var _Config=require('../Config');var _Encapsulator=require('../Encapsulator');var _Relay=require('../Relay');var _socks=require('../../socks5');var _Constants=require('../../socks5/Constants');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var Logger=_log4js2.default.getLogger(_path2.default.basename(__filename,'.js'));var Socket=exports.Socket=function(){function Socket(_ref){var _this=this;var id=_ref.id,socket=_ref.socket;_classCallCheck(this,Socket);this._id=null;this._socket=null;this._tcpRelay=null;this._udpRelay=null;this._socksTcpReady=false;this._socksUdpReady=false;this._targetAddress=null;this._decipher=null;this._cipher=null;this._iv=null;Logger.setLevel(_Config.Config.log_level);this._id=id;this._socket=socket;this.updateCiphers();// events
socket.on('error',function(err){return _this.onError(socket,err)});socket.on('close',function(had_error){return _this.onClose(socket,had_error)});socket.on('data',function(buffer){return _this.onReceiving(socket,buffer)});Logger.info('client['+this._id+'] connected')}_createClass(Socket,[{key:'obtainIV',value:function obtainIV(buffer){if(buffer.length<_Crypto.CRYPTO_IV_LEN+9){if(Logger.isFatalEnabled()){Logger.fatal('cannot obtain iv from client, packet is too small ('+buffer.length+'bytes)')}return null}return buffer.slice(-_Crypto.CRYPTO_IV_LEN)}},{key:'updateCiphers',value:function updateCiphers(){var _this2=this;var collector=function collector(buffer){return _this2.onReceived(buffer)};var iv=this._iv===null?undefined:this._iv;this._cipher=_Crypto.Crypto.createCipher(collector,iv);this._decipher=_Crypto.Crypto.createDecipher(collector,iv)}},{key:'getRelay',value:function getRelay(){// return tcp relay
if(this._socksTcpReady||_Config.Config.isServer){return this._tcpRelay=this._tcpRelay||new _Relay.TcpRelay({id:this._id,socket:this._socket})}// return udp relay
if(this._socksUdpReady||_Config.Config.isServer){return this._udpRelay=this._udpRelay||new _Relay.UdpRelay({id:this._id,socket:this._socket})}return null}},{key:'onReceiving',value:function onReceiving(socket,buffer){if(_Config.Config.isServer){this._decipher.write(buffer)}else{// socks5 handshake, client only
if(!this._socksTcpReady&&!this._socksUdpReady){this.onSocksHandshake(socket,buffer);return}var _buffer=buffer;if(this._socksUdpReady){var request=_socks.UdpRequestMessage.parse(buffer);if(request!==null){// just drop RSV and FRAG
_buffer=request.DATA}else{if(Logger.isWarnEnabled()){Logger.warn('['+this._id+'] -x-> dropped unidentified packet '+buffer.length+' bytes')}return}}// send with iv, if needed
if(this._iv===null&&_Config.Config.use_iv){// 1. generate iv for each connection
this._iv=_Crypto.Crypto.generateIV();// 2. pack then send out
this._cipher.write(_Encapsulator.Encapsulator.pack(this._targetAddress,Buffer.concat([_buffer,this._iv])).toBuffer());// 3. update socket ciphers
this.updateCiphers();// 4. update relay ciphers
this.getRelay().setIV(this._iv)}else{// send without iv
this._cipher.write(_Encapsulator.Encapsulator.pack(this._targetAddress,_buffer).toBuffer())}}}},{key:'onReceived',value:function onReceived(buffer){var relay=this.getRelay();if(_Config.Config.isServer){// obtain iv from the first packet if needed
if(this._iv===null&&_Config.Config.use_iv){this._iv=this.obtainIV(buffer);if(this._iv===null){this._socket.end();this._socket.destroy();return}// TODO(refactor): simplify the post-process to buffer
var buf=buffer.slice(0,buffer.length-_Crypto.CRYPTO_IV_LEN);var newLen=_Encapsulator.Encapsulator.numberToArray(buf.readUInt16BE(0)-_Crypto.CRYPTO_IV_LEN);buf[0]=newLen[0];buf[1]=newLen[1];relay.setIV(this._iv);relay.forwardToDst(buf);this.updateCiphers();return}relay.forwardToDst(buffer)}else{relay.forwardToServer(buffer)}}},{key:'onError',value:function onError(socket,err){switch(err.code){case'ECONNRESET':Logger.warn('client['+this._id+'] '+err.message);return;case'EPIPE':Logger.warn('client['+this._id+'] '+err.message);return;default:Logger.error(err);break;}}},{key:'onClose',value:function onClose(socket,had_error){if(had_error){Logger.warn('client['+this._id+'] closed due to a transmission error')}else{Logger.info('client['+this._id+'] closed normally')}if(this._tcpRelay!==null){this._tcpRelay.close()}}},{key:'onSocksHandshake',value:function onSocksHandshake(socket,buffer){// 1. IDENTIFY
var identifier=_socks.IdentifierMessage.parse(buffer);if(identifier!==null){var message=new _socks.SelectMessage;socket.write(message.toBuffer());return}// 2. REQUEST
var request=_socks.RequestMessage.parse(buffer);if(request!==null){var type=request.CMD;switch(type){case _Constants.REQUEST_COMMAND_UDP:// UDP ASSOCIATE
case _Constants.REQUEST_COMMAND_CONNECT:{this._targetAddress=new _Address.Address({ATYP:request.ATYP,DSTADDR:request.DSTADDR,DSTPORT:request.DSTPORT});// reply success
var _message=new _socks.ReplyMessage({REP:_Constants.REPLY_SUCCEEDED});socket.write(_message.toBuffer());if(type===_Constants.REQUEST_COMMAND_CONNECT){this._socksTcpReady=true}else{this._socksUdpReady=true}break}default:{var _message2=new _socks.ReplyMessage({REP:_Constants.REPLY_COMMAND_NOT_SUPPORTED});socket.write(_message2.toBuffer());break}}}}}]);return Socket}();