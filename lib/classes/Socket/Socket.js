'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Socket=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();var _log4js=require('log4js');var _log4js2=_interopRequireDefault(_log4js);var _AdvancedBuffer=require('../AdvancedBuffer');var _Connection=require('../Connection');var _Relay=require('../Relay');var _Crypto=require('../Crypto');var _Config=require('../Config');var _socks=require('../../socks5');var _Constants=require('../../socks5/Constants');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var Logger=_log4js2.default.getLogger('Socket');var Socket=exports.Socket=function(){function Socket(_ref){var _this=this;var id=_ref.id,socket=_ref.socket;_classCallCheck(this,Socket);this._id=null;this._relay=null;this._socksReady=false;this._buffer=new _AdvancedBuffer.AdvancedBuffer({getPacketLength:function getPacketLength(bytes){return _Crypto.Crypto.decrypt(bytes).readUIntBE(0,bytes.length)}});Logger.setLevel(_Config.Config.log_level);this._id=id;this._socket=socket;// TODO: create Relay when Socks5 handshake was done
this._relay=new _Relay.Relay({id:this._id,socket:socket});// events
this._buffer.on('data',function(buffer){return _this.onReceived(buffer)});socket.on('data',function(buffer){return _this.onReceiving(socket,buffer)});socket.on('error',function(err){return _this.onError(socket,err)});socket.on('close',function(had_error){return _this.onClose(socket,had_error)});Logger.info('client['+this._id+'] connected')}_createClass(Socket,[{key:'onReceiving',value:function onReceiving(socket,buffer){if(!this._socksReady&&!_Config.Config.isServer){// only client side should do socks5 handle shake
this.socksHandShake(socket,buffer);return}if(_Config.Config.isServer){// NOTE: We should take advantages of AdvancedBuffer to get a complete packet.
//       DO NOT decrypt the buffer(chunk) at once it was received, or AES will fail.
this._buffer.put(buffer)}else{this.onReceived(buffer)}}},{key:'onReceived',value:function onReceived(buffer){this._relay.send(buffer)}},{key:'onError',value:function onError(socket,err){switch(err.code){case'ECONNRESET':Logger.warn('client['+this._id+'] '+err.message);return;case'EPIPE':Logger.warn('client['+this._id+'] '+err.message);return;default:Logger.error(err);break;}}},{key:'onClose',value:function onClose(socket,had_error){if(had_error){Logger.warn('client['+this._id+'] closed due to a transmission error')}else{Logger.info('client['+this._id+'] closed normally')}this._relay.close()}},{key:'socksHandShake',value:function socksHandShake(socket,buffer){// 1. IDENTIFY
var identifier=_socks.IdentifierMessage.parse(buffer);if(identifier!==null){var message=new _socks.SelectMessage;socket.write(message.toBuffer());return}// 2. REQUEST
var request=_socks.RequestMessage.parse(buffer);if(request&&request.CMD===_Constants.REQUEST_COMMAND_CONNECT){var connection=new _Connection.Connection({ATYP:request.ATYP,DSTADDR:request.DSTADDR,DSTPORT:request.DSTPORT});this._relay.setConnection(connection);// ACK
var _message=new _socks.ReplyMessage({REP:_Constants.REPLY_SUCCEEDED});socket.write(_message.toBuffer());this._socksReady=true;// done.
}}}]);return Socket}();