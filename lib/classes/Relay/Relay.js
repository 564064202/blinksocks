'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.Relay=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();var _net=require('net');var _net2=_interopRequireDefault(_net);var _log4js=require('log4js');var _log4js2=_interopRequireDefault(_log4js);var _Config=require('../Config');var _Connection=require('../Connection');var _Crypto=require('../Crypto');var _Encapsulator=require('../Encapsulator');var _AdvancedBuffer=require('../AdvancedBuffer');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}// import {Tracer} from '../Tracer';
var Logger=_log4js2.default.getLogger('Relay');/**
 * return 6 length hash string of a buffer, for debugging
 * @param buffer
 * @returns {string}
 */function hash(buffer){return _Crypto.Crypto.hash(buffer).slice(0,6)}/**   <- backward                forward ->
 *  +----------------------------------------+
 *  | this._lsocket |  Relay  | this._socket |
 *  +----------------------------------------+
 */var Relay=exports.Relay=function(){// only available on client-side, will be packed in every out packet
// backward net.Socket
function Relay(options){_classCallCheck(this,Relay);this._id=null;this._lsocket=null;this._socket=null;this._connection=null;this._buffer=new _AdvancedBuffer.AdvancedBuffer({getPacketLength:function getPacketLength(bytes){return _Crypto.Crypto.decrypt(bytes).readUIntBE(0,bytes.length)}});this._isConnected=false;Logger.setLevel(_Config.Config.log_level);this._id=options.id;this._lsocket=options.socket}// forward net.Socket
_createClass(Relay,[{key:'setConnection',value:function setConnection(connection){this._connection=connection}// private
},{key:'_connect',value:function _connect(host,port,callback){var _this=this;this._socket=_net2.default.connect({host:host,port:port},function(){Logger.info('['+_this._id+'] ==> '+host+':'+port);_this._isConnected=true;if(typeof callback!=='undefined'){callback(_this._socket)}});this._socket.on('error',function(err){_this.onError({host:host,port:port},err);// callback(null);
});this._socket.on('data',function(buffer){return _this.onReceiving(buffer)});this._buffer.on('data',function(buffer){return _this.onReceived(buffer)})}},{key:'connect',value:function connect(conn,callback){var _conn$getEndPoint=conn.getEndPoint(),_conn$getEndPoint2=_slicedToArray(_conn$getEndPoint,2),host=_conn$getEndPoint2[0],port=_conn$getEndPoint2[1];this._connect(host,port,callback)}},{key:'onError',value:function onError(_ref,err){var host=_ref.host,port=_ref.port;switch(err.code){case'ECONNREFUSED':Logger.warn('['+this._id+'] =x=> '+host+':'+port);break;case'ECONNRESET':Logger.warn('['+this._id+'] '+err.message);break;case'ETIMEDOUT':Logger.warn('['+this._id+'] '+err.message);break;case'EAI_AGAIN':Logger.warn('['+this._id+'] '+err.message);break;case'EPIPE':Logger.warn('['+this._id+'] '+err.message);return;default:Logger.error(err);break;}if(!this._socket.destroyed){this._socket.end()}if(!this._lsocket.destroyed){this._lsocket.end()}}},{key:'onReceiving',value:function onReceiving(buffer){if(_Config.Config.isServer){this.onReceived(buffer)}else{// Tracer.dump(`Relay_${this._id}_en`, buffer);
// NOTE: DO NOT decrypt the buffer(chunk) at once, or AES decryption will fail.
this._buffer.put(buffer)}}/**
   * send data backward via this._lsocket.write()
   * @param buffer
   */},{key:'onReceived',value:function onReceived(buffer){if(_Config.Config.isServer){var encrypted=_Crypto.Crypto.encrypt(_Encapsulator.Encapsulator.pack(new _Connection.Connection,buffer).toBuffer());Logger.info('['+this._id+'] <-- '+encrypted.length+' bytes (+header,encrypted,hash='+hash(encrypted)+') <-- '+buffer.length+' bytes(origin,hash='+hash(buffer)+')');this._lsocket.write(encrypted);// Tracer.dump(`Relay_${this._id}_en`, encrypted);
}else{var decrypted=_Crypto.Crypto.decrypt(buffer);var frame=_Encapsulator.Encapsulator.unpack(decrypted);if(frame===null){Logger.warn('['+this._id+'] <-x- dropped unidentified packet '+buffer.length+' bytes');return}var payload=frame.PAYLOAD;if(this._lsocket.destroyed){Logger.warn('['+this._id+'] <-x- '+payload.length+' bytes (-header,decrypted) <-- '+buffer.length+' bytes')}else{Logger.info('['+this._id+'] <-- '+payload.length+' bytes (-header,hash='+hash(payload)+') <-- '+buffer.length+' bytes(encrypted,hash='+hash(buffer)+')');this._lsocket.write(payload)}}}/**
   * send data forward via this._socket.write()
   * @param buffer
   */},{key:'send',value:function send(buffer){if(_Config.Config.isServer){this.sendFromServer(buffer)}else{this.sendFromClient(buffer)}}},{key:'sendFromServer',value:function sendFromServer(buffer){var _this2=this;var decrypted=_Crypto.Crypto.decrypt(buffer);var frame=_Encapsulator.Encapsulator.unpack(decrypted);if(frame===null){Logger.warn('['+this._id+'] -x-> dropped unidentified packet '+buffer.length+' bytes');return}var payload=frame.PAYLOAD;var _send=function _send(data){if(!_this2._socket.destroyed){Logger.info('['+_this2._id+'] --> '+buffer.length+' bytes(encrypted,hash='+hash(buffer)+') --> '+data.length+' bytes (-header,hash='+hash(data)+')');_this2._socket.write(data)}else{Logger.warn('['+_this2._id+'] -x-> '+buffer.length+' bytes -x-> '+data.length+' bytes (-header,decrypted)');_this2._lsocket.end()}};// connect to real server if not connected yet
if(!this._isConnected){var conn=new _Connection.Connection({ATYP:frame.ATYP,DSTADDR:frame.DSTADDR,DSTPORT:frame.DSTPORT});this.connect(conn,function(){// send payload of frame
_send(payload)});return}_send(payload)}},{key:'sendFromClient',value:function sendFromClient(buffer){var _this3=this;var encrypted=_Crypto.Crypto.encrypt(_Encapsulator.Encapsulator.pack(this._connection,buffer).toBuffer());var _send=function _send(data){Logger.info('['+_this3._id+'] --> '+buffer.length+' bytes(origin,hash='+hash(buffer)+') --> '+data.length+' bytes (+header,encrypted,hash='+hash(data)+')');_this3._socket.write(data)};// connect to our server if not connected yet
if(!this._isConnected){this._connect(_Config.Config.server_host,_Config.Config.server_port,function(){_send(encrypted)});return}_send(encrypted)}},{key:'close',value:function close(){if(this._socket!==null&&!this._socket.destroyed){this._socket.end()}}}]);return Relay}();